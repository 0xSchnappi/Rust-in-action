# Memory

## 原始指针

风险：

1. 原始指针并不拥有它们的值。当访问他们的时候，Rust编译器也不会检查所引用的数据是否仍然有效
2. 让多个原始指针都指向同一个数据，这也是允许的。这样每一个原始指针都可以对此数据进行读/写访问。在这种情况下，Rust是不会去保证共享数据的有效性的。

不可避免的使用原始指针的情况：

1. 有些操作系统调用或者是某些第三方的代码需要用到原始指针。在与C代码提供的外部接口打交道时，这时使用原始指针就是很常见的了。
2. 当共享访问某些数据是必需的，并且运行时性能又非常关键的时候。也许你的应用程序中有多个组件需要平等的访问一些计算成本较高的变量。在这种情况下，可能会出现一个组件中的某些低级错误影响到其他所有的组件的情况，如果你愿意冒这个风险，那么原始指针将是可供选择的最后手段之一。

## 智能指针类型

| 名称            | 简介                                                                                                       | 能力                                                                                                 | 弱点                                                 |
| --------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| `Raw Pointer` | `*mut T`和 `*const T`,是指针世界中的“自由激进分子"。速度非常快，但是非常不安全                        | 速度快<br />能与外部世界进行交互                                                                     | 不安全                                               |
| `Box <T>`     | 在箱子中存放的任何东西。能够iou接受几乎任何类型，用于长时间的存储，也是新的”安全编程时代"的主力           | 在一个叫”堆“的集中存储位置保存一个值                                                               | 占用更多空间                                         |
| `Rc<T>`       | 引用计数指针，`Rc<T>`是Rust中能干、但却吝啬的”薄记员"。是谁、在什么时候、借用了什么东西，它都非常清楚。 | 共享访问某些值                                                                                       | 占用更多空间<br />带来运行的开销<br />非线程安全     |
| `Arc<T>`      | `Arc<T>`是Rust中的“使节"。它能够跨线程共享访问某些值，并且能够保证各线程共享访问时互补冲突              | 共享访问某些值<br />线程安全                                                                         | 占用更多空间<br />带来运行时开销                     |
| `Cell<T>`     | `Cell<T>`擅长的是变形，它能够修改不可变的值                                                              | 内部可变性                                                                                           | 占用更多空间<br />性能低                             |
| `RefCell<T>`  | 使用 `RefCell<T>`，可以在不可变引用中执行修改。这种古怪的能力会带来开销                                  | 内部可变性<br />可以嵌套在 `Rc`和 `Arc`中使用，`Rc`和 `Arc`只能接受不可变的引用              | 占用更多空间<br />带来运行时开销<br />缺少编译时保证 |
| `Cow<T>`      | 如果你只需要读它，为什么还要在上面写下一些东西呢？可能是你想要在上面做出一些修改吧。这就是 `Cow`的作用了 | 当需要只读访问时，避免写入                                                                           | 可能会占用更多空间                                   |
| `String`      | `String`向我们展示了如何构建安全的抽象，可以把它当作一个如何处理用户输入的不确定性的指南                 | 按需动态增长<br />在运行时保证编码正确性                                                             | 分配的空间大小可能会超过实际的需要                   |
| `Arc<T>`      | 程序中的主要存储系统。随着值的创建和销毁，`Arc<T>`始终保持数据的有序性                                   | 按需动态增长                                                                                         | 分配的空间大小                                       |
| `RawVec<T>`   | `Vec<T>`的底层基石，当然也是其他许多动态大小类型的底层基石。它知道该如何根据需要给数据提供一个”家"      | 按需动态增长<br />与内存分配器一起工作，找到要分配的空间                                             | 一般不会直接应用在你的代码中                         |
| `Unique<T>`   | 一个值的唯一拥有者，唯一能保证拥有完全的控制的指针                                                         | 诸如String等类型的基础类型，需要独占值                                                               | 不适合直接在应用程序代码中                           |
| `Shared<T>`   | 要想实现共享所有权是困难的。使用 `Shared<T>`能让此功能的实现稍微容易一些                                 | 共享所有权<br />能够分配 `T`类型大小的内存，甚至在个 `T`是零大小的也可以，那就无须占用内存空间了 | 不适合直接在应用程序代码中使用                       |

> 对于内部可变性，你可能希望在一个方法中通过其中一个参数获取一个不可变的值，但是又想让该值具有可变性。如果你愿意为此付出一些运行时开销，那么假装一个不可变性就是可能的。
>
> 如果方法需要此参数是一个拥有所有权的值，那么可以把参数包装在 `Cell<T>`中。如果需要的是引用，则可以包装在 `RefCell<T>`中，在使用引用计数类型 `Rc<T>`和 `Arc<T>`时，如果只能接收不可变的参数，那么可以把 `Cell<T>`或 `RefCell<T>`包装在其中，这种用法也很常见，包装后的类型看起来类似 `Rc<RefCell<T>>`。这种类型意味着，你付出了两次运行时开销，但很明显其在使用时更具灵活性。

- `core::ptr::Unique`：它是许多类型的基础类型，例如 `String`、`Box<T>`，还有 `Vec<T>`的底层指针字段
- `core::ptr::Shared`：它是 `Rc<T>`和 `Arc<T>`的基础类型，能够处理需要共享访问的情况
- 内部深度互联的数据结构可以从类型 `std::rc::Weak`和 `std::arc::Weak`中获益，这两个类型分别对应于单线程和多线程的场景。它们允许访问 `Rc/Arc`内部的数据，而不会增加其引用计数。这样可以防止指针用无休止的循环。
- `alloc::raw_vec::RawVec`为实现 `Vec<T>`和 `VecDeq<T>`提供了底层支持。`VecDeq<T>`是一个可扩展的双端队列。
- `std::cell::UnsafeCell`是实现 `Cell<T>`和 `RefCell<T>`的底层类型。如果你想让你的类型能够提供内部可变性，，那么此类型的实现是值得研究的。
